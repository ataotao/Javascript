/**************************************************************************
 * 作用域链(Scope Chain) 定义
 ***************************************************************************/
console.log('------------ECMAScript 允许创建内部函数，我们甚至能从父函数中返回这些函数。------------');
// 作用域链与一个执行上下文相关，变量对象的链用于在标识符解析中变量查找。
// 函数上下文的作用域链在函数调用时创建的，包含活动对象和这个函数内部的[[scope]]属性。下面我们将更详细的讨论一个函数的[[scope]]属性。
var x = 10;

function foo() {
    var y = 20;
    function bar() {
        console.log(x + y);
    }
    return bar;
}

foo()(); // 30

/**************************************************************************
 * 函数的生命周期 函数的的生命周期分为创建和激活阶段（调用时）
 ***************************************************************************/
console.log('------------函数创建------------');

(function () {
    function foo() {
        var y = 20;
        console.log(x + y);
    }
    foo(); // null
    var x = 10;
})();

console.log('------------函数激活------------');
// 在向上查找中，一个上下文中的局部变量较之于父作用域的变量拥有较高的优先级。万一两个变量有相同的名称但来自不同的作用域，那么第一个被发现的是在最深作用域中。
(function () {

    var x = 10;

    function foo() {
        var y = 20;

        function bar() {
            var y = 30;
            console.log(x + y);
        }

        bar();
    }

    foo(); // 40

})();


/**************************************************************************
 * 作用域特征
 ***************************************************************************/
console.log('------------闭包------------');
var xx = 10;

function foox() {
    console.log(xx);
}

(function () {
    var xx = 20;
    foox(); // 10, but not 20
})();
console.log('------------通过构造函数创建的函数的[[scope]]------------');

// 我们看到，通过函数构造函数（Function constructor）创建的函数“bar”，是不能访问变量“y”的。但这并不意味着函数“barFn”没有[[scope]]属性（否则它不能访问到变量“x”）。问题在于通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象。考虑到这一点，如通过这种函数创建除全局之外的最上层的上下文闭包是不可能的。
(function () {

    var x = 10;

    function foo() {

        var y = 20;

        function barFD() { // 函数声明
            console.log(x);
            console.log(y);
        }

        var barFE = function () { // 函数表达式
            console.log(x);
            console.log(y);
        };

        var barFn = Function('console.log(x); console.log(y);');

        barFD(); // 10, 20
        barFE(); // 10, 20
        //barFn(); // 10, "y" is not defined

    }

    foo();

})();


console.log('------------------代码执行时对作用域链的影响--------------------');
/**
 * 在进入上下文时发生了什么？标识符“x”和“y”已被添加到变量对象中。此外，在代码运行阶段作如下修改：
 * 
 * x = 10, y = 10;
 * 对象{x:20}添加到作用域的前端;
 * 在with内部，遇到了var声明，当然什么也没创建，因为在进入上下文时，所有变量已被解析添加;
 * 在第二步中，仅修改变量“x”，实际上对象中的“x”现在被解析，并添加到作用域链的最前端，“x”为20，变为30;
 * 同样也有变量对象“y”的修改，被解析后其值也相应的由10变为30;
 * 此外，在with声明完成后，它的特定对象从作用域链中移除（已改变的变量“x”－－30也从那个对象中移除），即作用域链的结构恢复到with得到加强以前的状态。
 * 在最后两个alert中，当前变量对象的“x”保持同一，“y”的值现在等于30，在with声明运行中已发生改变。
 */

(function () {
    var x = 10, y = 10;
    with ({ x: 20 }) {

        var x = 30, y = 30;

        console.log(x); // 30
        console.log(y); // 30
    }

    console.log(x); // 10
    console.log(y); // 30

})();

